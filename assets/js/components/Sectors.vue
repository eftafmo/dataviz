<template>
<div class="sectors-viz" :style="{minHeight: svgWidth + 'px'}">  <!-- todo: a better way to preserve container height? -->
  <svg :viewBox="`0 0 ${width} ${height}`">
    <g class="chart" :transform="`translate(${margin + radius},${margin + radius})`">
    </g>
  </svg>
  <div class="legend" :style="{minHeight: svgWidth + 'px'}">
    <!-- much repetition here, but not worth doing a recursive component -->
    <transition-group
        tag="ul"
        class="sectors"
        name="item"
    >
      <li
          v-for="sector in data.children"
          v-if="sector.value"
          :key="getLabelID(sector)"
          :id="getLabelID(sector)"
          :class="{selected: filters.sector == sector.data.id}"
          :style="{color: _colour(sector)}"
      >
        <a @click="click(sector)">
          <span :style="{background: _colour(sector)}"></span>
          <span>
            {{ sector.data.name }}
          </span>
          <span
              v-show="filters.sector != sector.data.id"
              :key="`v-${getLabelID(sector)}`">
            {{ format(sector.value) }}
          </span>
          <span
              v-if="filters.sector == sector.data.id"
              class="icon icon-close"
          />
        </a>

        <transition
            v-on:before-enter="areasBeforeEnter"
            v-on:before-leave="areasBeforeLeave"
            v-on:after-enter="areasReset"
            v-on:after-leave="areasReset"
            v-on:enter-cancelled="areasCancelled"
            v-on:leave-cancelled="areasCancelled"
            name="areas"
        >
          <transition-group
              v-show="filters.sector == sector.data.id"
              tag="ul"
              class="areas"
              name="item"
          >
            <li
                v-for="area in sector.children"
                v-if="area.value"
                :key="getLabelID(area)"
                :id="getLabelID(area)"
                :class="{ inactive: filters.area &&
                                    filters.sector == area.parent.data.id &&
                                    filters.area != area.data.id
                        }"
            >
              <a @click="click(area)">
                <span :style="{background: _colour(area)}"></span>
                <span>
                  {{ area.data.name }}
                </span>
                <span :key="`v-${getLabelID(area)}`">
                  {{ format(area.value) }}
                </span>
              </a>
            </li>
          </transition-group>
        </transition>
      </li>
    </transition-group>
  </div>
</div>
</template>

<style lang="less">
.sectors-viz {
  // defs
  @text-colour: #444;
  // these need to be synced with js
  @duration: .5s;
  @inactive_opacity: .7;

  svg {
    width: 50%;
    height: auto;
    display: block;
  }
  .legend {
    width: 50%;
    height: auto;
    position: relative;
    left: 50%;
    margin-top: -50%;
  }

  .chart path, .legend a {
    cursor: pointer;
  }

  .legend {
    ul {
      &.areas {
        margin-left: 2.6rem;
        // the vertical spacing has to be on the inside
        // because we animate height
        li:first-of-type {
          padding-top: 1rem;
        }
      }
      list-style-type: none;
      padding: 0;
      font-size: 1.4rem;

      li {
        margin-bottom: 0.3rem;

        &.selected > a {
          font-size: 120%;
          border-style: none;
          padding: 0;

          span:first-child {
            width: 2rem;
            height: 2rem;
            flex: 0 0 2rem;
          }

          &:hover {
            span.icon-close {
              color: #000;
              font-weight: bold;
            }
          }
        }

        &.selected span.icon-close {
          font-size: 120%;
        }

        a {
          display: flex;
          padding: .4rem;
          text-decoration: none;
          color: @text-colour;
          border: 1px solid transparent;
          border-radius: .2rem;

          &:hover {
            border-color: #cdf;
          }

          * {
            display: block;
            flex-grow: 1;
            margin: 0 0.2rem 0 0.2rem;
          }
          span:first-child {
            flex: 0 0 1.8rem;
            width: 1.8rem;
            height: 1.8rem;
            margin-left: 0;
            margin-right: 0.6rem;
          }
          *:last-child {
            margin-right: 0;
            text-align: right;
          }
        }
      }
    }

    .areas li {
      transition: all @duration;
    }
    .areas li.inactive {
      filter: grayscale(100%);
      opacity: @inactive_opacity;
    }

    /* animations:
     * -enter, -leave apply during the first frame only;
     * -*-active applies throughout the entire transition;
     * -*-to appplies during the last frame only;
     * -move applies only to items within a transition-group.

    /* these apply to all legend items, both sectors and areas.
     * useful when triggered by external filters.
     */

    .item-enter-active, .item-leave-active {
      transition: opacity @duration;
    }
    // (dis)appearing item fades in/out
    .item-enter, .item-leave-to {
      opacity: 0;
    }
    // remaining items move about
    // (this applies automatically when another item appears)
    .item-move {
      transition: transform @duration;
    }
    // setting this causes other items to get -move when one disappears
    .item-leave-active {
      position: absolute;
    }

    /* the areas list appears when filtering by parent sector
     */
    .areas-enter-active, .areas-leave-active {
      overflow: hidden;
      transition: height @duration, opacity @duration;
    }
    /*
    // things seem to look better without opacity
    // TODO: test
    .areas-enter, .areas-leave-to {
      opacity: 0;
    }
    .areas-enter-to, .areas-leave {
      opacity: 1;
    }
    */
  }
}
</style>

<script>
import Vue from 'vue';
import * as d3 from 'd3';

import BaseMixin from './mixins/Base';
import ChartMixin from './mixins/Chart';
import {SectorColours} from 'js/constants.js';


export default Vue.extend({
  mixins: [
    BaseMixin, ChartMixin,
  ],

  data() {
    return {
      width: 500,
      height: 500,

      margin: 10,

      // percentage of mid-donut void
      inner_radius: .65,

      // these need to be synced with the css
      duration: 500,
      inactive_opacity: .7,
    };
  },

  computed: {
    data() {
      // TODO: avoid spurious run with empty data / track isReady()?
      //if (this.dataset === undefined) return;

      const tree = d3.hierarchy( { children: this.dataset } );

      // simplest way to get this recomputed on filter changes
      // is to access filter data right here.

      // filtering by sectors / areas makes items "disabled".
      const isEnabled = (this.filters.sector === null ?
        ( () => true ) :
        ( (d) => !d.allocation ? d.id == this.filters.sector :
                                 d.parent == this.filters.sector )
      );

      tree.sum( (d) => {
        // only last level has allocation
        if (!d.allocation) return 0;
        // filter out disabled items
        if (!isEnabled(d)) return 0;

        return d3.sum(
          d3.entries(d.allocation),
          (item) => {
            // allocation is grouped by FM, so filter if needed
            if (this.filters.fm
                && item.key != this.filters.fm) return 0;

            return item.value;
          }
        );
      } );

      return tree;
    },

    radius() {
      return Math.min(this.width, this.height) / 2 - this.margin;
    },

    _primary_colour() {
      const keys = [],
            values = [];
      for (let k in SectorColours) {
        keys.push(k);
        values.push(SectorColours[k]);
      }
      return d3.scaleOrdinal()
        .domain(keys)
        .range(values)
      // fail hard on missing values
        .unknown(null)
    },

    _partition() {
      return d3.partition().size([this.radius * 2, this.radius * 2]);
    },
    _angle() {
      return d3.scaleLinear()
               .domain([0, this.radius * 2])
               .range([0, Math.PI * 2]);
    },
    _arc() {
      return d3.arc()
        // the Math.min/max part  is needed to avoid funkiness for edge items
        .startAngle( (d) => Math.max(0, Math.min(2 * Math.PI, this._angle(d.x0))) )
        .endAngle( (d) => Math.max(0, Math.min(2 * Math.PI, this._angle(d.x1))) )
        .outerRadius(this.radius)
        .innerRadius(this.radius * this.inner_radius);
        //.outerRadius((d) => d.depth == 1 ? this.radius * .75 * 1.1: this.radius)
        //.innerRadius((d) => d.depth == 1 ? this.radius * .5 : this.radius * .75 * 0.9);
    },
  },

  mounted() {
    this.root = null;
    this._secondary_colours = {};
    // this one's used during transitioning below
    this._areasCancelled = [];
  },

  methods: {
    areasBeforeEnter(el) {
      // get height from a clone, it's safer
      const c = el.cloneNode(true);
      c.style.visibility = "hidden";
      c.style.removeProperty("display");
      c.style.height = "auto";
      el.parentNode.appendChild(c);
      const h = c.clientHeight;
      c.remove();

      // start from 0, but only if we didn't interrupt another transition
      const _idx = this._areasCancelled.indexOf(el);
      if (_idx === -1)
        el.style.height = "0px";
      else
        this._areasCancelled.splice(_idx, 1);


      // using setTimeout is the only way to get predictable results
      setTimeout( () => el.style.height = h + "px", 1);
    },

    areasBeforeLeave(el) {
      // start from current height (unless another transition is in progress)
      const _idx = this._areasCancelled.indexOf(el);
      if (_idx === -1)
        el.style.height = el.clientHeight + "px";
      else
        this._areasCancelled.splice(_idx, 1);

      setTimeout( () => el.style.height = "0px", 1);
    },

    areasReset(el) {
      el.style.removeProperty("height");
    },

    areasCancelled(el, x){
      this._areasCancelled.push(el);
    },

    processDataset(ds) {
      // add a reference to the parent sector to all areas
      // to keep track of filtering
      for (const s of ds) {
        for (const a of s.children) {
          a.parent = s.id;
        }
      }
      return ds;
    },

    _extract_coords: (d) => (
      {
        x0: d.x0, x1: d.x1,
        y0: d.y0, y1: d.y1,
        depth: d.depth,
      }
    ),

    _colour(d) {
      const func = (
        d.depth == 1 ?
          this._primary_colour :
          this._secondary_colours[d.parent.data.name] || (
            () => console.error("Missing colour for " + d.parent.data.name)
          )
      );
      return func(d.data.name);
    },

    _mkcolourscale: (colour, length) => {
      if (length == 1) return d3.scaleOrdinal([colour]);

      const _c = d3.hsl(colour);
      let start = d3.hsl(_c.h, _c.s, _c.l, _c.opacity),
	  end = d3.hsl(_c.h, _c.s, _c.l, _c.opacity);

      const _delta = d3.scaleLinear()
            // these values are rather arbitrary but they look pretty
	    .domain([2, 5])
	    .range([0.1, 0.5])
	    .clamp(true)
      (length);

      // make the starting colour _delta% more saturated,
      start.s = Math.min(1, start.s + start.s * _delta);
      // and slightly darker
      start.l = Math.max(0, start.l - start.l * _delta);
      // and the ending colour a bit lighter,
      end.l = Math.min(0.95, end.l + end.l * _delta);

      const _range = d3.range(length);
      let _scale = d3.scaleLinear()
	  .domain([0, length - 1])
	  .range([start, end])
	  .interpolate(d3.interpolateHsl);

      return d3.scaleOrdinal(d3.range(length).map(_scale));
    },

    _getID(node) {
      // include parent id, because area clash makes boom
      const parent = node.depth == 2 ? this._getID(node.parent) + "_" : "";
      return parent + node.data.id;
    },
    getArcID(node) { return "a-" + this._getID(node); },
    getLabelID(node) { return "l-" + this._getID(node); },

    renderChart() {
      this.rendered = true;
      const $this = this,
            // flatten data
            data = this._partition(this.data)
                       .descendants()
                       .slice(1);
      const t = this.getTransition();


      // generate children colours. TODO: move to processDataset
      // or earlier. (fully pre-computed?)
      for (let d of this.data.children) {
        // TODO: make colours id-based
        const name = d.data.name;

        this._secondary_colours[name] = this._mkcolourscale(
          SectorColours[name], d.children.length
        );
      }

      const arcs = this.chart
	    .selectAll(".arc")
	    .data(data, this.getArcID); // JOIN

      const aentered = arcs.enter().append("path") // ENTER
        .each(function(d) {
	  // cache current coordinates
	  this._prev = $this._extract_coords(d);
	})
        .attr("id", this.getArcID)
	.attr("class", "arc")
	.attr("d", this._arc)
	.attr("fill", this._colour)
        // level 2 items are hidden
        .attr("opacity", (d) => d.depth == 2 ? 0 : null )
        // and really hidden
        .style("display", (d) => d.depth == 2 ? "none" : null );

      const aexit = arcs.exit(); // EXIT

      /* transitions */
      // this stuff is complicated, each selection group will need its own transition
      // (actually ^^ that is a lie, there are no enter animations, and exit
      // never happens, but the code below is ready in case the logic changes).

      // NOTE: not merging with ENTER, because there's not ENTER transition now.
      // will need to be handled if things change.
      const transitioning = arcs // UPDATE
        .transition(t)
        // we can't use this._arc directly as it yields funky distortions,
        // so we need a custom interpolation. attrTween to the rescue
        .attrTween('d', function(d) {
	  const interpolate = d3.interpolate(
	    this._prev, $this._extract_coords(d)
	  );
          this._prev = interpolate(0);

          return function(x) {
            return $this._arc(interpolate(x));
          }
        });
      // if we've selected a sector, let's show its areas
      if (this.filters.sector) {
        transitioning
          .filter(
            (d) => d.parent.data.id == this.filters.sector
          )
          .style("display", null)
          .attr("opacity", 1);
      }
      // and hide the previous ones
      if (this._prevsector) {
        transitioning
          .filter(
            (d) => d.parent.data.id == this._prevsector
          )
          .attr("opacity", 0)
          // and also reset possibly grayed out areas §
          .attr("fill", this._colour)
          // don't forget to re-disable it
          .on("end", function() { this.style.display = "none"; });

        // we reset the prevsector during next tick only,
        // to avoid race conditions with handleFilterArea §
        this.$nextTick(
          () => this._prevsector = null
        );
      }

      // send new items to back so existing arcs cover them
      // during the transition and make them look animated
      // (but make sure areas are in front of sectors)
      aentered // ENTER
        .filter( (d) => d.depth == 2 )
        .lower();
      aentered
        .filter( (d) => d.depth == 1 )
        .lower();

      // send deleted items to back too
      aexit // EXIT
        .lower()
        .transition(t)
        .remove()

      /* events */
      aentered
        .on("click", this.click);
    },

    click(d) {
      const func = d.depth == 1 ? this.toggleSector : this.toggleArea;
      func(d.data.id, this);
    },

    toggleSector(s, etarget) {
      this.filters.sector = this.filters.sector == s ?
                            null : s;
    },

    toggleArea(a, etarget) {
      if (!this.filters.sector) {
        console.error("Filtered by area without a sector. Impossible 1.")
        return;
      }
      this.filters.area = this.filters.area == a ?
                          null : a;
      // TODO: what if the area does not to the current sector belong?
      // TODO: we need a persistent array of PS / PAs
    },

    handleFilterSector(val, old) {
      // remember the previos sector, it's used in various places,
      // and clear it during render
      this._prevsector = old;

      // always reset area on sector change
      this.filters.area = null;

      this.render();
    },

    handleFilterArea(val) {
      // don't go through a full render, as
      // this only needs to gray out sibling areas.

      // but WARNING, WARNING: transitions in d3 are element-exclusive, §
      // so in case the area filter was cleared by switching away
      // from the parent sector we can't handle this here.
      // we'll let the default sector-triggered render() take care of it. §
      if (val === null && this._prevsector) {
        return;
      }

      // WARNING: TODO: if the user filters by area while the sector-filtering
      // transition is in progress, something will break. bug hidden in here.

      if (val !== null && this.filters.sector === null)
        console.error("Filtered by area without a sector. Impossible 2.")

      const areas = this.chart
                        .selectAll(".arc")
                        .filter(
                          (d) => d.parent.data.id == this.filters.sector
                        );
      // TODO: unify this with the default colour func?
      const colourfunc = (val === null ? this._colour :
        (d) => {
          const c = this._colour(d);
          if (d.data.id == this.filters.area) return c;

          // a simple(istic) algorithm to transform the colour to grayscale:
          // compute the average of r, g, b
          const r = d3.rgb(c),
                x = (r.r + r.g + r.b) / 3,
                // we'll also simulate an opacity decrease here
                // (we can't simply use opacity because there's a sector below)
                y = x + (255 - x) * (1 - this.inactive_opacity);
          return d3.rgb(y, y, y);
        }
      );

      areas
        .transition(this.getTransition())
        // TODO: if this was already grayed out it would be nice to pass
        // momentarily through the default colour
        .attr("fill", colourfunc);
    },

    handleFilterFm() {
      this.render();
    },
  },
});

</script>
